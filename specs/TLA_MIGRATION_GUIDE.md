# Migrating Existing TLA+ Specs to Embedded Python

## Purpose

This guide provides step-by-step instructions for migrating existing TLA+
specifications from `specs/tla/*.tla` files to embedded Python `@formal_spec`
decorators.

## Overview

**Before (Current):**

```
specs/tla/
├── RedisMailbox.tla          # 370 lines of TLA+
├── RedisMailboxMC.tla        # Model checking config
└── RedisMailboxMC.cfg        # TLC configuration

src/weakincentives/contrib/mailbox/
└── _redis.py                 # Python implementation (separate)
```

**After (Target):**

```
src/weakincentives/contrib/mailbox/
└── _redis.py                 # Implementation + embedded spec

specs/tla/extracted/          # Generated by pytest --extract-tla
├── RedisMailbox.tla          # Auto-generated from @formal_spec
└── RedisMailbox.cfg          # Auto-generated config
```

## Migration Strategy

### Step 1: Understand the Current Spec

Read and understand `specs/tla/RedisMailbox.tla`:

```bash
# View the current spec
cat specs/tla/RedisMailbox.tla | head -100

# Identify key sections:
# - CONSTANTS
# - VARIABLES
# - Actions (Send, Receive, Acknowledge, Nack, Extend, ReapOne)
# - Invariants (MessageStateExclusive, HandleValidity, etc.)
```

### Step 2: Create Skeleton Decorator

Add import and skeleton decorator to `_redis.py`:

```python
# src/weakincentives/contrib/mailbox/_redis.py

from weakincentives.formal import formal_spec, StateVar, Action, Invariant

@formal_spec(
    module="RedisMailbox",
    extends=("Integers", "Sequences", "FiniteSets", "TLC"),
    constants={},  # Fill in Step 3
    state_vars=[],  # Fill in Step 4
    helpers={},     # Fill in Step 5
    actions=[],     # Fill in Step 6
    invariants=[],  # Fill in Step 7
)
class RedisMailbox:
    """Redis-backed mailbox implementation with SQS-compatible semantics.

    This implementation is formally verified. The embedded TLA+ specification
    can be extracted and model-checked with:

        pytest --check-tla

    For spec details, see the @formal_spec decorator above.
    """
    # ... existing implementation ...
```

### Step 3: Migrate Constants

From `RedisMailbox.tla`:

```tla
CONSTANTS
    MaxMessages,
    MaxDeliveries,
    NumConsumers,
    VisibilityTimeout
```

To Python:

```python
@formal_spec(
    module="RedisMailbox",
    constants={
        "MaxMessages": 3,
        "MaxDeliveries": 3,
        "NumConsumers": 2,
        "VisibilityTimeout": 2,
    },
    # ...
)
```

### Step 4: Migrate Variables

From `RedisMailbox.tla`:

```tla
VARIABLES
    pending,            \* Sequence of message IDs in pending list
    invisible,          \* Function: msg_id -> {expiresAt, handle}
    data,               \* Function: msg_id -> body (or NULL if deleted)
    handles,            \* Function: msg_id -> current valid handle suffix
    deleted,            \* Set of deleted message IDs
    now,                \* Abstract time counter
    nextMsgId,          \* Counter for generating message IDs
    nextHandle,         \* Counter for generating handle suffixes
    consumerState,      \* Function: consumer_id -> {holding, handle}
    deliveryCounts,     \* Function: msg_id -> count (persists across requeue)
    deliveryHistory     \* Function: msg_id -> Sequence of (count, handle)
```

To Python:

```python
@formal_spec(
    module="RedisMailbox",
    state_vars=[
        StateVar("pending", "Seq(MessageId)", "Sequence of message IDs in pending list"),
        StateVar("invisible", "Function", "Function: msg_id -> {expiresAt, handle}"),
        StateVar("data", "Function", "Function: msg_id -> body (or NULL if deleted)"),
        StateVar("handles", "Function", "Function: msg_id -> current valid handle suffix"),
        StateVar("deleted", "Set", "Set of deleted message IDs"),
        StateVar("now", "Nat", "Abstract time counter"),
        StateVar("nextMsgId", "Nat", "Counter for generating message IDs"),
        StateVar("nextHandle", "Nat", "Counter for generating handle suffixes"),
        StateVar("consumerState", "Function", "Function: consumer_id -> {holding, handle}"),
        StateVar("deliveryCounts", "Function", "Function: msg_id -> count (persists across requeue)"),
        StateVar("deliveryHistory", "Function", "Function: msg_id -> Sequence of (count, handle)"),
    ],
    # ...
)
```

### Step 5: Migrate Helper Operators

From `RedisMailbox.tla`:

```tla
NULL == 0

InPending(msgId) ==
    \E i \in 1..Len(pending): pending[i] = msgId

RemoveKey(f, k) ==
    [m \in (DOMAIN f) \ {k} |-> f[m]]

UpdateFunc(f, k, v) ==
    [m \in (DOMAIN f) \cup {k} |-> IF m = k THEN v ELSE f[m]]
```

To Python:

```python
@formal_spec(
    module="RedisMailbox",
    helpers={
        "NULL": "0",
        "InPending(msgId)": r"\E i \in 1..Len(pending): pending[i] = msgId",
        "RemoveKey(f, k)": r"[m \in (DOMAIN f) \ {k} |-> f[m]]",
        "UpdateFunc(f, k, v)": r"[m \in (DOMAIN f) \cup {k} |-> IF m = k THEN v ELSE f[m]]",
    },
    # ...
)
```

**Note:** Use raw strings (`r"..."`) to avoid escaping backslashes.

### Step 6: Migrate Actions

From `RedisMailbox.tla`:

```tla
Send(body) ==
    /\ nextMsgId <= MaxMessages
    /\ LET msgId == nextMsgId
       IN /\ pending' = Append(pending, msgId)
          /\ data' = UpdateFunc(data, msgId, body)
          /\ deliveryCounts' = UpdateFunc(deliveryCounts, msgId, 0)
          /\ deliveryHistory' = UpdateFunc(deliveryHistory, msgId, <<>>)
          /\ nextMsgId' = nextMsgId + 1
    /\ UNCHANGED <<invisible, handles, deleted, now, nextHandle, consumerState>>
```

To Python:

```python
@formal_spec(
    module="RedisMailbox",
    actions=[
        Action(
            name="Send",
            parameters=("body",),
            preconditions=(
                "nextMsgId <= MaxMessages",
            ),
            updates={
                "pending": "Append(pending, nextMsgId)",
                "data": "UpdateFunc(data, nextMsgId, body)",
                "deliveryCounts": "UpdateFunc(deliveryCounts, nextMsgId, 0)",
                "deliveryHistory": "UpdateFunc(deliveryHistory, nextMsgId, <<>>)",
                "nextMsgId": "nextMsgId + 1",
            },
            description="Send a new message to the pending queue",
        ),
        # ... more actions
    ],
    # ...
)
```

**Important:** The `UNCHANGED` clause is automatically generated for variables
not mentioned in `updates`.

### Step 7: Migrate Invariants

From `RedisMailbox.tla`:

```tla
MessageStateExclusive ==
    \A msgId \in 1..nextMsgId-1:
        LET inPending == InPending(msgId)
            inInvisible == msgId \in DOMAIN invisible
            inDeleted == msgId \in deleted
        IN (inPending /\ ~inInvisible /\ ~inDeleted) \/
           (~inPending /\ inInvisible /\ ~inDeleted) \/
           (~inPending /\ ~inInvisible /\ inDeleted)
```

To Python:

```python
@formal_spec(
    module="RedisMailbox",
    invariants=[
        Invariant(
            id="INV-1",
            name="MessageStateExclusive",
            predicate=r"""
\A msgId \in 1..nextMsgId-1:
    LET inPending == InPending(msgId)
        inInvisible == msgId \in DOMAIN invisible
        inDeleted == msgId \in deleted
    IN (inPending /\ ~inInvisible /\ ~inDeleted) \/
       (~inPending /\ inInvisible /\ ~inDeleted) \/
       (~inPending /\ ~inInvisible /\ inDeleted)
""".strip(),
            description="A message must be in exactly one state: pending, invisible, or deleted",
        ),
        # ... more invariants
    ],
    # ...
)
```

**Note:** Multi-line predicates are supported. Use triple-quoted raw strings
for readability.

## Complete Migration Example

Here's what the fully migrated `RedisMailbox` decorator looks like:

```python
# src/weakincentives/contrib/mailbox/_redis.py

from weakincentives.formal import formal_spec, StateVar, Action, Invariant

@formal_spec(
    module="RedisMailbox",
    extends=("Integers", "Sequences", "FiniteSets", "TLC"),
    constants={
        "MaxMessages": 3,
        "MaxDeliveries": 3,
        "NumConsumers": 2,
        "VisibilityTimeout": 2,
    },
    state_vars=[
        StateVar("pending", "Seq(MessageId)", "Sequence of message IDs in pending list"),
        StateVar("invisible", "Function", "msg_id -> {expiresAt, handle}"),
        StateVar("data", "Function", "msg_id -> body (or NULL if deleted)"),
        StateVar("handles", "Function", "msg_id -> current valid handle suffix"),
        StateVar("deleted", "Set", "Set of deleted message IDs"),
        StateVar("now", "Nat", "Abstract time counter"),
        StateVar("nextMsgId", "Nat", "Counter for generating message IDs"),
        StateVar("nextHandle", "Nat", "Counter for generating handle suffixes"),
        StateVar("consumerState", "Function", "consumer_id -> {holding, handle}"),
        StateVar("deliveryCounts", "Function", "msg_id -> count (persists across requeue)"),
        StateVar("deliveryHistory", "Function", "msg_id -> Seq of (count, handle) for INV-4"),
    ],
    helpers={
        "NULL": "0",
        "InPending(msgId)": r"\E i \in 1..Len(pending): pending[i] = msgId",
        "RemoveKey(f, k)": r"[m \in (DOMAIN f) \ {k} |-> f[m]]",
        "UpdateFunc(f, k, v)": r"[m \in (DOMAIN f) \cup {k} |-> IF m = k THEN v ELSE f[m]]",
    },
    actions=[
        Action(
            name="Send",
            parameters=("body",),
            preconditions=("nextMsgId <= MaxMessages",),
            updates={
                "pending": "Append(pending, nextMsgId)",
                "data": "UpdateFunc(data, nextMsgId, body)",
                "deliveryCounts": "UpdateFunc(deliveryCounts, nextMsgId, 0)",
                "deliveryHistory": "UpdateFunc(deliveryHistory, nextMsgId, <<>>)",
                "nextMsgId": "nextMsgId + 1",
            },
            description="Send a new message to the pending queue",
        ),
        Action(
            name="Receive",
            parameters=("consumer",),
            preconditions=(
                "Len(pending) > 0",
                "consumerState[consumer].holding = NULL",
            ),
            updates={
                "pending": "Tail(pending)",
                "invisible": (
                    "UpdateFunc(invisible, Head(pending), "
                    "[expiresAt |-> now + VisibilityTimeout, handle |-> nextHandle])"
                ),
                "handles": "UpdateFunc(handles, Head(pending), nextHandle)",
                "deliveryCounts": "[deliveryCounts EXCEPT ![Head(pending)] = @ + 1]",
                "deliveryHistory": (
                    "[deliveryHistory EXCEPT ![Head(pending)] = "
                    "Append(@, [count |-> deliveryCounts[Head(pending)] + 1, handle |-> nextHandle])]"
                ),
                "nextHandle": "nextHandle + 1",
                "consumerState": (
                    "[consumerState EXCEPT ![consumer] = "
                    "[holding |-> Head(pending), handle |-> nextHandle]]"
                ),
            },
            description="Receive: atomically move message from pending to invisible",
        ),
        Action(
            name="Acknowledge",
            parameters=("consumer",),
            preconditions=(
                "consumerState[consumer].holding /= NULL",
                "consumerState[consumer].holding \\in DOMAIN handles",
                "handles[consumerState[consumer].holding] = consumerState[consumer].handle",
                "consumerState[consumer].holding \\in DOMAIN invisible",
            ),
            updates={
                "invisible": "RemoveKey(invisible, consumerState[consumer].holding)",
                "data": "RemoveKey(data, consumerState[consumer].holding)",
                "handles": "RemoveKey(handles, consumerState[consumer].holding)",
                "deliveryCounts": "RemoveKey(deliveryCounts, consumerState[consumer].holding)",
                "deleted": "deleted \\cup {consumerState[consumer].holding}",
                "consumerState": (
                    "[consumerState EXCEPT ![consumer] = [holding |-> NULL, handle |-> 0]]"
                ),
            },
            description="Acknowledge: successfully complete message processing",
        ),
        Action(
            name="AcknowledgeFail",
            parameters=("consumer",),
            preconditions=(
                "consumerState[consumer].holding /= NULL",
                r"\/ consumerState[consumer].holding \notin DOMAIN handles",
                r"\/ handles[consumerState[consumer].holding] /= consumerState[consumer].handle",
                r"\/ consumerState[consumer].holding \notin DOMAIN invisible",
            ),
            updates={
                "consumerState": (
                    "[consumerState EXCEPT ![consumer] = [holding |-> NULL, handle |-> 0]]"
                ),
            },
            description="Acknowledge fails if handle is stale",
        ),
        Action(
            name="Nack",
            parameters=("consumer", "newTimeout"),
            preconditions=(
                "consumerState[consumer].holding /= NULL",
                "consumerState[consumer].holding \\in DOMAIN handles",
                "handles[consumerState[consumer].holding] = consumerState[consumer].handle",
                "consumerState[consumer].holding \\in DOMAIN invisible",
            ),
            updates={
                "pending": (
                    "IF newTimeout = 0 THEN Append(pending, consumerState[consumer].holding) ELSE pending"
                ),
                "invisible": (
                    "IF newTimeout = 0 "
                    "THEN RemoveKey(invisible, consumerState[consumer].holding) "
                    "ELSE [invisible EXCEPT ![consumerState[consumer].holding].expiresAt = now + newTimeout, "
                    "![consumerState[consumer].holding].handle = 0]"
                ),
                "handles": "RemoveKey(handles, consumerState[consumer].holding)",
                "consumerState": (
                    "[consumerState EXCEPT ![consumer] = [holding |-> NULL, handle |-> 0]]"
                ),
            },
            description="Nack: return message to queue with optional delay",
        ),
        Action(
            name="ReapOne",
            parameters=(),
            preconditions=(
                r"\E msgId \in DOMAIN invisible: invisible[msgId].expiresAt < now",
            ),
            updates={
                "pending": "Append(pending, CHOOSE msgId \\in DOMAIN invisible: invisible[msgId].expiresAt < now)",
                "invisible": "RemoveKey(invisible, CHOOSE msgId \\in DOMAIN invisible: invisible[msgId].expiresAt < now)",
                "handles": "RemoveKey(handles, CHOOSE msgId \\in DOMAIN invisible: invisible[msgId].expiresAt < now)",
                "consumerState": (
                    "[c \\in DOMAIN consumerState |-> "
                    "IF consumerState[c].holding = (CHOOSE msgId \\in DOMAIN invisible: invisible[msgId].expiresAt < now) "
                    "THEN [holding |-> NULL, handle |-> 0] "
                    "ELSE consumerState[c]]"
                ),
            },
            description="Reap: move one expired message back to pending",
        ),
        Action(
            name="Tick",
            parameters=(),
            preconditions=(),
            updates={"now": "now + 1"},
            description="Tick: advance abstract time",
        ),
    ],
    invariants=[
        Invariant(
            id="INV-1",
            name="MessageStateExclusive",
            predicate=r"""
\A msgId \in 1..nextMsgId-1:
    LET inPending == InPending(msgId)
        inInvisible == msgId \in DOMAIN invisible
        inDeleted == msgId \in deleted
    IN (inPending /\ ~inInvisible /\ ~inDeleted) \/
       (~inPending /\ inInvisible /\ ~inDeleted) \/
       (~inPending /\ ~inInvisible /\ inDeleted)
""".strip(),
            description="A message must be in exactly one state: pending, invisible, or deleted",
        ),
        Invariant(
            id="INV-2-3",
            name="HandleValidity",
            predicate=r"""
\A c \in 1..NumConsumers:
    LET state == consumerState[c]
    IN state.holding /= NULL =>
        (state.holding \in DOMAIN handles =>
            handles[state.holding] = state.handle)
""".strip(),
            description="Consumers holding a message have a valid handle for it",
        ),
        Invariant(
            id="INV-4",
            name="DeliveryCountMonotonic",
            predicate=r"""
\A msgId \in DOMAIN deliveryHistory:
    LET history == deliveryHistory[msgId]
    IN \A i \in 1..Len(history)-1:
        history[i].count < history[i+1].count
""".strip(),
            description="Delivery counts are strictly increasing",
        ),
        Invariant(
            id="INV-4b",
            name="DeliveryCountPersistence",
            predicate=r"""
\A msgId \in DOMAIN deliveryCounts:
    \A i \in 1..Len(deliveryHistory[msgId]):
        deliveryHistory[msgId][i].count = i
""".strip(),
            description="Delivery counts persist across requeue",
        ),
        Invariant(
            id="INV-5",
            name="NoMessageLoss",
            predicate=r"""
\A msgId \in DOMAIN data:
    LET inPending == InPending(msgId)
        inInvisible == msgId \in DOMAIN invisible
    IN inPending \/ inInvisible
""".strip(),
            description="Every message with data is either pending or invisible",
        ),
        Invariant(
            id="INV-7",
            name="HandleUniqueness",
            predicate=r"""
\A msgId \in DOMAIN deliveryHistory:
    LET history == deliveryHistory[msgId]
    IN \A i, j \in 1..Len(history):
        i /= j => history[i].handle /= history[j].handle
""".strip(),
            description="Each delivery of a message gets a unique handle",
        ),
    ],
)
class RedisMailbox:
    """Redis-backed mailbox implementation with SQS-compatible semantics.

    This implementation is formally verified against the embedded TLA+
    specification above. The spec can be extracted and model-checked with:

        pytest --check-tla

    For spec documentation, see specs/VERIFICATION.md.
    """

    # ... existing implementation ...
```

## Step 8: Extract and Validate

After adding the decorator, extract and validate:

```bash
# Extract the embedded spec
pytest --extract-tla

# Compare with original
diff specs/tla/RedisMailbox.tla specs/tla/extracted/RedisMailbox.tla

# If differences exist, iterate on the decorator until they match
```

**Note:** Some differences are expected:

- Generated code has comments like `(* Generated from Python ... *)`
- Variable ordering may differ
- Helper operators may be in a different order

Focus on **semantic equivalence**, not textual identity.

## Step 9: Model Check

Run TLC on the extracted spec:

```bash
# Model check the extracted spec
pytest --check-tla

# If errors occur, debug and iterate
```

Common issues:

- Syntax errors in TLA+ expressions (missing escapes, typos)
- Missing helper operators
- Incorrect action updates
- Invalid invariant predicates

## Step 10: Archive Original Spec

Once the extracted spec passes model checking and matches the original:

```bash
# Archive the original spec
mkdir -p specs/tla/archive
mv specs/tla/RedisMailbox.tla specs/tla/archive/
mv specs/tla/RedisMailboxMC.tla specs/tla/archive/
mv specs/tla/RedisMailboxMC.cfg specs/tla/archive/

# Update VERIFICATION.md to reference embedded spec
# Update AGENTS.md to mention the new approach
```

## Step 11: Update Documentation

Update references in documentation:

```bash
# Files to update:
# - specs/VERIFICATION.md: Update TLA+ spec location
# - AGENTS.md: Document the new embedded spec approach
# - README.md: Mention formal verification co-location
```

## Verification Checklist

Before archiving the original spec, verify:

- [ ] `@formal_spec` decorator is complete
- [ ] `pytest --extract-tla` succeeds
- [ ] Extracted `.tla` matches original semantically
- [ ] `pytest --check-tla` passes (TLC finds no errors)
- [ ] All invariants from original spec are present
- [ ] All actions from original spec are present
- [ ] Constants match original values
- [ ] Documentation updated

## Troubleshooting

### "Syntax error in TLA+ expression"

**Problem:** Invalid TLA+ syntax in `Action` or `Invariant`.

**Solution:**

- Use raw strings (`r"..."`) for backslashes
- Check TLA+ syntax in extracted file
- Consult TLA+ manual for correct syntax

### "Variable not found in DOMAIN"

**Problem:** Referring to a variable that doesn't exist in `updates`.

**Solution:**

- Ensure all state variables are defined in `state_vars`
- Check spelling matches exactly

### "Extracted spec doesn't match original"

**Problem:** Semantic differences between specs.

**Solution:**

- Compare action by action
- Check preconditions and updates
- Verify invariant predicates
- Ensure helper operators are defined

### "Model checking finds violation"

**Problem:** TLC finds a counterexample.

**Solution:**

- This might be a **real bug**!
- Review the counterexample trace
- Check if bug is in spec or implementation
- Fix and re-validate

## Performance Considerations

### Extraction Time

- **Fast:** <1 second for typical specs
- Happens at import time during pytest

### Model Checking Time

- **Depends on state space size**
- Small models (3 messages): ~1-5 seconds
- Large models (10+ messages): minutes to hours
- Use `StateConstraint` to bound exploration

### CI Integration

Recommendation:

- Run extraction on every commit (fast)
- Run model checking on changes to formal specs only (slow)
- Cache extracted specs between runs

## Next Steps

1. **Complete the migration** following this guide
2. **Update Makefile** (see Makefile section below)
3. **Update CI pipeline** to run `make check-tla`
4. **Document in AGENTS.md** for contributors
5. **Consider migrating other specs** if this proves successful

## See Also

- `specs/FORMAL_SPEC_GUIDE.md` - User guide for @formal_spec
- `specs/TLA_EMBEDDING.md` - Design rationale
- `specs/VERIFICATION.md` - Current verification approach
- `examples/formal_spec_example.py` - Working examples
